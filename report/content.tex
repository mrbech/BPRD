\section*{Introduction}
TODO

\section{Opgave 1}
\subsection{Implementation}
The changes needed for CLex.fsl consists of adding the "for", "to" and "do"
keywords to the lexer.
\begin{fs}
let keyword s =
    match s with
    ...
    | "for"     -> FOR
    | "to"      -> TO
    | "do"      -> DO
    ...
\end{fs}
The CPar.fsy parser then needs to be extended with the \texttt{FOR}, \texttt{TO}
and \texttt{DO} tokens to work with the Lexer. It is then possible to add the
new for-to loop statement in the StmtM and StmtU declaration. I have chosen to
directly parse the for-to loop into already existing abstract syntex. Therefor I
have made no changes to \texttt{Comp.fs} or \texttt{Absyn.fs}.

The for-to loop is translated as shown in the given assignment, using a while
loop and doing the following: 
\begin{enumerate}
    \item Inside of a block it first declare the counting variable and assign it
        to the initial value given by the user. 
    \item It then insert a while loop that loops until the counting variable
        have reached the limit that the user have set. 
    \item Inside the while loop we insert the users statement and end the while
        loop by increment the counting variable.
\end{enumerate}
The code snippets can be found bellow:

\begin{fs}
%token FOR TO DO
...
StmtM:
...
  | FOR NAME ASSIGN Expr TO Expr DO StmtM { Block[Dec(TypI, $2); Stmt(Expr(Assign(AccVar($2), $4))); Stmt(While(Prim2("<=", Access(AccVar($2)), $6), Block[Stmt($8);Stmt(Expr(Assign(AccVar($2), Prim2("+", Access(AccVar($2)), CstI(1)))))]))] }
...
StmtU:
  | FOR NAME ASSIGN Expr TO Expr DO StmtU { Block[Dec(TypI, $2); Stmt(Expr(Assign(AccVar($2), $4))); Stmt(While(Prim2("<=", Access(AccVar($2)), $6), Block[Stmt($8);Stmt(Expr(Assign(AccVar($2), Prim2("+", Access(AccVar($2)), CstI(1)))))]))] }
\end{fs}
\subsection{Test}
Below is my test example code. It uses the for-loop to print the numbers 0 - 10
and ends by printing a newline. Resulting in an output like the following:
\texttt{0 1 2 3 4 5 6 7 8 9 10}
\begin{ccode}
void main() {
  for i=0 to 10 do 
    print i;

  println;
}
\end{ccode}
\subsection{Result}
To run the example I use two extra file, one called mcc.fs and Makefile both can
be found in the appendix with a short description of what they do. With the two
files in the same directory as the MicroC code and the example code stored in
\texttt{examples} directory I can do the following to test my example:
\begin{bashcode}
make
./mcc.exe examples/ex1.c examples/ex1.out
javac Machine.java
java Machine examples/ex1.out
\end{bashcode}
This gives me the expect output of:
\begin{bashcode}
% java Machine examples/ex2.out
0 1 2 3 4 5 6 7 8 9 10

\end{bashcode}

\section{Opgave 2}
\subsection{Implementation}
For the \texttt{CLex.fsl} lexer the plus equal and minus equal tokens are needed
and can be seen below.
\begin{fs}
rule Token = parse
...
  | "+="            { PEQ }
  | "-="            { MEQ }
...
\end{fs}
The \texttt{CPar.fsy} parser will also need the two new tokens. We also need to add precedence for
the two new tokens, they are non-associative similar to greater-than, less-than
etc. The expressions can then be added to the \texttt{ExprNotAccess} declaration as seen
bellow, being parsed into two new abstract syntax expressions.
\begin{fs}
%token PEQ MEQ
...
%nonassoc GT LT GE LE
%nonassoc PEQ MEQ 
%left PLUS MINUS
...
ExprNotAccess:
...
  | Access PEQ Expr                     { PlusEq($1, $3)      } 
  | Access MEQ Expr                     { MinusEq($1, $3)     } 

\end{fs}
In the abstract syntax found in the \texttt{Absyn.fs} file we add the two new
expression to the \texttt{expr} declaration. The both consists of a tuple of type access and expression.
\begin{fs}
and expr =                                                         
  | PlusEq of access * expr          (* x+=e or *p+=e or a[e]+=e    *)
  | MinusEq of access * expr         (* x-=e or *p-=e or a[e]-=e    *)
\end{fs}
In the compiler implementation found in \texttt{Comp.fs} we add two new match
cases in \texttt{cExpre}. The two expressions have a similar implementation, and
compiles to the following:
\begin{enumerate}
    \item Puts the left hand side's stack index on the stack (\texttt{cAccess})
    \item Duplicates the access on the stack, to avoid double evaluation of the
        left hand side \[DUP\]
    \item Loads the left hand side value unto the stack \[LDI\]
    \item Evaluates the right hand side expression (\texttt{cExpr})
    \item Adds or subtracts the expression from the accessed value \[ADD\] \[SUB\] 
    \item Stores the result of the calculation in the left hand side's stack
        index \[STI\] (left over from \[DUP\])
\end{enumerate}
The code snippet can be found bellow.
\begin{fs}
and cExpr (e : expr) (varEnv : varEnv) (funEnv : funEnv) : instr list = 
...
    | PlusEq(acc, e)  -> cAccess acc varEnv funEnv @ [DUP] @ [LDI] @ cExpr e varEnv funEnv @ [ADD] @ [STI]
    | MinusEq(acc, e)  -> cAccess acc varEnv funEnv @ [DUP] @ [LDI] @ cExpr e varEnv funEnv @ [SUB] @ [STI]
\end{fs}

\subsection{Test Example}
Below is my test example code. It starts by declaring a new array with two
elements and a variable \texttt{i}, it then initialises i to 0, the first element the
array to 10 and the second element of the array to 100.

To test that there are no double access of \texttt{i} as describe in the
exercise, we assign the \texttt{i} variable to it self plus on and in the same
expression uses it to access and plus equal the array element with 100. We then
print the two array elements and the i, the result should be that \texttt{10 200
1} is printed, if there is no double access and the update have happened
successfully. The minus equal is the tested in a similar fashion using a
variable \texttt{j} and should result in \texttt{10 100 1} printed.
\begin{ccode}
void main() {
    int arr[2];
    int i;
    i = 0;
    arr[0] = 10;
    arr[1] = 100;
    
    arr[i=i+1] += 100;
    print arr[0];
    print arr[1];
    print i;
    println;

    int j;
    j = 2;
    arr[j=j-1] -= 100;
    print arr[0];
    print arr[1];
    print j;
    println;
}
\end{ccode}
\subsection{Result}
The output is as expected and can be seen below:
\begin{bashcode}
% java Machine examples/ex2.out
10 200 1 
10 100 1
\end{bashcode}

\section{Opgave 3}
\subsection{Implemetation}
Machine.fs:
\begin{fs}
type instr =
    | INDEX 
...
let CODEINDEX  = 26
let makelabenv (addr, labenv) instr = 
    match instr with
    | INDEX          -> (addr+1, labenv)
...
let rec emitints getlab instr ints = 
    match instr with
    | INDEX          -> CODEINDEX  :: ints
...
\end{fs}
Machine.java:
\begin{ccode}
final static int INDEX = 26;
static int execcode(int[] p, int[] s, int[] iargs, boolean trace) {
...
    switch (p[pc++]) {
        case INDEX:
        int a = sp-2;
        int q = s[a];
        int n = a - q;
        int i = s[sp];
        if(0 <= i && i < n){
            s[sp-1] = s[s[sp-1]]+s[sp];
            sp--;
        }else{
            System.out.println("Array Index Out of Bounds");
            System.exit(1);
        }
        break;
...
\end{ccode}

Comp.fs:
\begin{fs}
...
and cAccess access varEnv funEnv : instr list =
    match access with 
    | AccIndex(acc, idx) -> cAccess acc varEnv funEnv @ cExpr idx varEnv funEnv @ [INDEX]
...
\end{fs}

\subsection{Effect of Index Checks}

\subsection{Test Program}
\begin{ccode}
void main(int i, int j) {
    int arr[16];
    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;
    print arr[i];
    arr[j] = 42;
    print arr[j];
}
\end{ccode}
\subsection{Result}
\begin{bashcode}
% java Machine examples/ex3.out 1 1
20 42 

% java Machine examples/ex3.out 16 1
Array Index Out of Bounds

% java Machine examples/ex3.out 1 16
20 Array Index Out of Bounds
\end{bashcode}

\section{Opgave 4}
\subsection{Implementation}

\pagebreak
\section{Appendix}
\subsection{mcc.fs}
\begin{fs}
module mcc

open ParseAndComp

[<EntryPoint>]
let main(args) =
    printf "%A" (compileToFile (fromFile args.[0]) args.[1])
    0;;
\end{fs}
\subsection{Makefile}
\lstinputlisting[numbers=left, language=make, breaklines=true]{../src/Makefile}
